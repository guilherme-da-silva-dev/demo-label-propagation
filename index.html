<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de Propagação de Rótulos Ponderado</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        .control-panel {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease-in-out;
        }
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 5px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        .graph-container {
            border: 1px solid #e2e8f0;
            background-color: #ffffff;
            cursor: grab;
        }
        .graph-container:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="antialiased text-slate-700">
    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-slate-800">Visualizador de Propagação de Rótulos Ponderado</h1>
            <p class="text-lg text-slate-600 mt-2">Gere grafos ponderados, inicie a propagação e veja a influência das conexões.</p>
            <p class="text-md text-slate-500 mt-1">Use o scroll do mouse para dar zoom e arraste o fundo para mover o grafo.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <!-- Painel de Controle -->
            <div class="lg:col-span-4 xl:col-span-3">
                <div class="control-panel p-6 sticky top-8">
                    <h2 class="text-2xl font-semibold mb-6 border-b pb-3 text-slate-800">Controles</h2>
                    
                    <!-- Seleção de Grafo -->
                    <div class="mb-6">
                        <label for="graph-type" class="block text-sm font-medium text-slate-700 mb-2">Tipo de Grafo</label>
                        <select id="graph-type" class="w-full p-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                            <option value="random">Aleatório (Erdos-Rényi)</option>
                            <option value="small-world">Mundo Pequeno (Watts-Strogatz)</option>
                            <option value="scale-free">Sem Escala (Barabási-Albert)</option>
                        </select>
                    </div>

                    <!-- Parâmetros do Grafo -->
                    <div id="params-container" class="space-y-4 mb-6">
                        <!-- Parâmetros serão injetados aqui pelo JS -->
                    </div>

                    <button id="generate-btn" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-md hover:bg-indigo-700 shadow-lg btn">
                        Gerar Grafo
                    </button>

                    <hr class="my-6 border-slate-200">

                    <!-- Controles da Simulação -->
                    <div class="space-y-4">
                        <button id="start-lpa-btn" class="w-full bg-emerald-500 text-white font-bold py-2 px-4 rounded-md hover:bg-emerald-600 shadow-lg btn" disabled>
                            Iniciar Propagação
                        </button>
                        <div id="timeline-container" class="hidden">
                            <label for="timeline-slider" class="block text-sm font-medium text-slate-700 mb-2">Linha do Tempo (Iteração: <span id="iteration-label">0</span>)</label>
                            <input type="range" id="timeline-slider" min="0" max="0" value="0" class="w-full">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Visualização do Grafo -->
            <div class="lg:col-span-8 xl:col-span-9">
                <div id="graph-container" class="w-full h-[75vh] rounded-lg shadow-lg overflow-hidden relative">
                    <div id="loading-spinner" class="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center hidden z-10">
                        <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-indigo-500"></div>
                    </div>
                    <svg id="graph-svg" class="w-full h-full"></svg>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuração Inicial e Variáveis Globais ---
        const graphTypeSelect = document.getElementById('graph-type');
        const paramsContainer = document.getElementById('params-container');
        const generateBtn = document.getElementById('generate-btn');
        const startLpaBtn = document.getElementById('start-lpa-btn');
        const timelineContainer = document.getElementById('timeline-container');
        const timelineSlider = document.getElementById('timeline-slider');
        const iterationLabel = document.getElementById('iteration-label');
        const svg = d3.select("#graph-svg");
        let width = document.getElementById('graph-container').clientWidth;
        let height = document.getElementById('graph-container').clientHeight;
        const loadingSpinner = document.getElementById('loading-spinner');

        let simulation, g, graphData = { nodes: [], links: [] }, history = [];
        const colors = d3.scaleOrdinal(d3.schemeCategory10);

        // --- Lógica de Zoom e Pan ---
        const zoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on("zoom", (event) => {
                if (g) {
                    g.attr("transform", event.transform);
                }
            });
        
        svg.call(zoom);

        // --- Lógica de Geração de Parâmetros da UI ---
        const paramsConfig = {
            random: `
                <div class="space-y-1">
                    <label for="nodes" class="text-sm font-medium">Nós (N)</label>
                    <input type="number" id="nodes" value="50" class="w-full p-2 border border-slate-300 rounded-md">
                </div>
                <div class="space-y-1">
                    <label for="prob" class="text-sm font-medium">Probabilidade (p)</label>
                    <input type="number" id="prob" value="0.1" step="0.01" min="0" max="1" class="w-full p-2 border border-slate-300 rounded-md">
                </div>`,
            'small-world': `
                <div class="space-y-1">
                    <label for="nodes" class="text-sm font-medium">Nós (N)</label>
                    <input type="number" id="nodes" value="50" class="w-full p-2 border border-slate-300 rounded-md">
                </div>
                <div class="space-y-1">
                    <label for="neighbors" class="text-sm font-medium">Vizinhos (K)</label>
                    <input type="number" id="neighbors" value="4" class="w-full p-2 border border-slate-300 rounded-md">
                </div>
                <div class="space-y-1">
                    <label for="rewire" class="text-sm font-medium">Reconexão (β)</label>
                    <input type="number" id="rewire" value="0.2" step="0.01" min="0" max="1" class="w-full p-2 border border-slate-300 rounded-md">
                </div>`,
            'scale-free': `
                 <div class="space-y-1">
                    <label for="nodes" class="text-sm font-medium">Nós Iniciais (m0)</label>
                    <input type="number" id="nodes" value="5" class="w-full p-2 border border-slate-300 rounded-md">
                </div>
                <div class="space-y-1">
                    <label for="edges" class="text-sm font-medium">Arestas (m)</label>
                    <input type="number" id="edges" value="2" class="w-full p-2 border border-slate-300 rounded-md">
                </div>
                 <div class="space-y-1">
                    <label for="total-nodes" class="text-sm font-medium">Nós Totais (N)</label>
                    <input type="number" id="total-nodes" value="50" class="w-full p-2 border border-slate-300 rounded-md">
                </div>`
        };

        function updateParamsUI() {
            paramsContainer.innerHTML = paramsConfig[graphTypeSelect.value];
        }

        // --- Lógica de Geração de Grafos Ponderados ---
        
        function createRandomGraph(n, p) {
            const nodes = Array.from({ length: n }, (_, i) => ({ id: i, label: null }));
            const links = [];
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (Math.random() < p) {
                        links.push({ source: i, target: j, weight: Math.random() * 4 + 1 });
                    }
                }
            }
            return { nodes, links };
        }

        function createSmallWorldGraph(n, k, beta) {
            const nodes = Array.from({ length: n }, (_, i) => ({ id: i, label: null }));
            const links = [];
            const adj = new Map(nodes.map(node => [node.id, new Set()]));

            for (let i = 0; i < n; i++) {
                for (let j = 1; j <= k / 2; j++) {
                    const target = (i + j) % n;
                    if (!adj.get(i).has(target)) {
                        links.push({ source: i, target: target, weight: Math.random() * 4 + 1 });
                        adj.get(i).add(target);
                        adj.get(target).add(i);
                    }
                }
            }

            links.forEach(link => {
                if (Math.random() < beta) {
                    const { source, target } = link;
                    let newTarget;
                    do {
                        newTarget = Math.floor(Math.random() * n);
                    } while (newTarget === source || adj.get(source).has(newTarget));
                    
                    adj.get(source).delete(target);
                    adj.get(target).delete(source);
                    
                    link.target = newTarget;
                    adj.get(source).add(newTarget);
                    adj.get(newTarget).add(source);
                }
            });
            
            const finalLinks = links.map(l => ({source: l.source, target: l.target, weight: l.weight}));
            return { nodes, links: finalLinks };
        }

        function createScaleFreeGraph(m0, m, N) {
            const nodes = Array.from({ length: m0 }, (_, i) => ({ id: i, label: null }));
            const links = [];
            const edgeList = [];

            for(let i = 0; i < m0; i++) {
                for(let j = i + 1; j < m0; j++) {
                    const weight = Math.random() * 4 + 1;
                    links.push({ source: i, target: j, weight });
                    edgeList.push(i, j);
                }
            }

            for (let i = m0; i < N; i++) {
                nodes.push({ id: i, label: null });
                const targets = new Set();
                while (targets.size < m && targets.size < edgeList.length) {
                    const randomNode = edgeList[Math.floor(Math.random() * edgeList.length)];
                    if (randomNode !== i) {
                       targets.add(randomNode);
                    }
                }
                targets.forEach(target => {
                    const weight = Math.random() * 4 + 1;
                    links.push({ source: i, target: target, weight });
                    edgeList.push(i, target);
                });
            }
            return { nodes, links };
        }

        // --- Lógica de Propagação de Rótulos Ponderada (Weighted LPA) ---

        // --- Lógica de Propagação de Rótulos Ponderada (Weighted LPA) ---
        // ATUALIZAÇÃO: A função initializeLabels foi modificada para garantir
        // que o número de rótulos únicos iniciais seja exatamente 'numLabels',
        // resultando em uma maior variedade de cores na propagação.

        function initializeLabels(nodes) {
            // 1. Determina quantos rótulos únicos teremos (entre 3% e 5% dos nós).
            const numLabels = Math.max(2, Math.floor(nodes.length * (Math.random() * 0.05 + 0.08)));

            // 2. Cria uma lista de rótulos únicos para serem distribuídos (ex: [0, 1, 2, 3]).
            let labelsToAssign = Array.from({ length: numLabels }, (_, i) => i);

            // 3. Embaralha os rótulos para manter a aleatoriedade na atribuição.
            labelsToAssign.sort(() => Math.random() - 0.5);

            // 4. Escolhe 'numLabels' nós aleatórios e únicos para receber os rótulos.
            const labeledIndices = new Set();
            while (labeledIndices.size < numLabels && labeledIndices.size < nodes.length) {
                labeledIndices.add(Math.floor(Math.random() * nodes.length));
            }

            // 5. Atribui um rótulo ÚNICO da nossa lista para cada nó escolhido.
            const indicesArray = Array.from(labeledIndices);
            indicesArray.forEach((nodeIndex, i) => {
                // Pega o próximo rótulo disponível da lista embaralhada.
                // O operador de módulo (%) é uma segurança para não estourar o array.
                const label = labelsToAssign[i % labelsToAssign.length];
                if (label !== undefined) {
                    nodes[nodeIndex].label = label;
                }
            });

            // A checagem de segurança, que já existia, continua útil para casos extremos.
            const uniqueLabels = [...new Set(nodes.filter(n => n.label !== null).map(n => n.label))];
            if (uniqueLabels.length < 2 && nodes.length > 1) {
                nodes.forEach(n => n.label = null); // Limpa para a recursão
                initializeLabels(nodes); // Tenta novamente se algo falhar
            }
        }

        async function runLabelPropagation() {
            loadingSpinner.classList.remove('hidden');
            startLpaBtn.disabled = true;
            generateBtn.disabled = true;

            const adj = new Map(graphData.nodes.map(n => [n.id, []]));
            graphData.links.forEach(l => {
                const sourceId = l.source.id ?? l.source;
                const targetId = l.target.id ?? l.target;
                adj.get(sourceId).push(targetId);
                adj.get(targetId).push(sourceId);
            });

            history = [JSON.parse(JSON.stringify(graphData.nodes.map(n => n.label)))];
            let changed = true;
            let iteration = 0;

            while (changed) {
                changed = false;
                const unlabeledNodes = graphData.nodes.filter(n => n.label === null);
                if (unlabeledNodes.length === 0) break;

                unlabeledNodes.sort(() => Math.random() - 0.5);

                unlabeledNodes.forEach(node => {
                    const neighbors = adj.get(node.id);
                    if (neighbors.length === 0) return;

                    const labelWeights = {};
                    neighbors.forEach(neighborId => {
                        const neighborNode = graphData.nodes[neighborId];
                        if (neighborNode.label !== null) {
                            const link = graphData.links.find(l => 
                                ((l.source.id ?? l.source) === node.id && (l.target.id ?? l.target) === neighborId) ||
                                ((l.target.id ?? l.target) === node.id && (l.source.id ?? l.source) === neighborId)
                            );
                            if (link) {
                                labelWeights[neighborNode.label] = (labelWeights[neighborNode.label] || 0) + link.weight;
                            }
                        }
                    });

                    if (Object.keys(labelWeights).length > 0) {
                        const maxWeight = Math.max(...Object.values(labelWeights));
                        const bestLabels = Object.keys(labelWeights).filter(label => labelWeights[label] === maxWeight);
                        const newLabel = parseInt(bestLabels[Math.floor(Math.random() * bestLabels.length)]);
                        
                        if (node.label !== newLabel) {
                            node.label = newLabel;
                            changed = true;
                        }
                    }
                });

                iteration++;
                history.push(JSON.parse(JSON.stringify(graphData.nodes.map(n => n.label))));
                updateVisualization(false);
                
                timelineSlider.max = iteration;
                timelineSlider.value = iteration;
                iterationLabel.textContent = iteration;
                
                await new Promise(resolve => setTimeout(resolve, 100)); 
            }
            
            loadingSpinner.classList.add('hidden');
            generateBtn.disabled = false;
            console.log(`Convergência alcançada em ${iteration} iterações.`);
        }


        // --- Lógica de Visualização (D3.js) ---
        
        function setupSimulation() {
            if (simulation) {
                simulation.stop();
            }
            simulation = d3.forceSimulation(graphData.nodes)
                .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(60))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .on("tick", ticked);
        }

        function updateVisualization(restartSimulation = true) {
            svg.selectAll("g").remove();
            g = svg.append("g");

            const link = g.append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.7)
                .selectAll("line")
                .data(graphData.links)
                .join("line")
                .attr("stroke-width", d => d.weight); // A espessura da aresta é baseada no seu peso

            const node = g.append("g")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll("circle")
                .data(graphData.nodes)
                .join("circle")
                .attr("r", 8)
                .attr("fill", d => d.label !== null ? colors(d.label) : "#ccc")
                .call(drag(simulation));

            node.append("title")
                .text(d => `Nó ${d.id}\nRótulo: ${d.label === null ? 'N/A' : d.label}`);
            
            if (simulation && restartSimulation) {
                simulation.nodes(graphData.nodes);
                simulation.force("link").links(graphData.links);
                simulation.alpha(1).restart();
            }
        }

        function ticked() {
            g.selectAll("line")
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            g.selectAll("circle")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        }
        
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }


        // --- Manipuladores de Eventos ---

        generateBtn.addEventListener('click', () => {
            const type = graphTypeSelect.value;
            let n, p, k, beta, m0, m, N;
            
            loadingSpinner.classList.remove('hidden');
            
            setTimeout(() => {
                try {
                    switch (type) {
                        case 'random':
                            n = parseInt(document.getElementById('nodes').value);
                            p = parseFloat(document.getElementById('prob').value);
                            graphData = createRandomGraph(n, p);
                            break;
                        case 'small-world':
                            n = parseInt(document.getElementById('nodes').value);
                            k = parseInt(document.getElementById('neighbors').value);
                            beta = parseFloat(document.getElementById('rewire').value);
                            graphData = createSmallWorldGraph(n, k, beta);
                            break;
                        case 'scale-free':
                            m0 = parseInt(document.getElementById('nodes').value);
                            m = parseInt(document.getElementById('edges').value);
                            N = parseInt(document.getElementById('total-nodes').value);
                            graphData = createScaleFreeGraph(m0, m, N);
                            break;
                    }

                    initializeLabels(graphData.nodes);
                    history = [JSON.parse(JSON.stringify(graphData.nodes.map(n => n.label)))];
                    
                    svg.call(zoom.transform, d3.zoomIdentity);

                    setupSimulation();
                    updateVisualization();
                    
                    startLpaBtn.disabled = false;
                    timelineContainer.classList.add('hidden');
                    timelineSlider.value = 0;
                    timelineSlider.max = 0;
                    iterationLabel.textContent = 0;

                } catch (error) {
                    alert(`Erro ao gerar o grafo: ${error.message}`);
                } finally {
                    loadingSpinner.classList.add('hidden');
                }
            }, 50);
        });

        startLpaBtn.addEventListener('click', () => {
            timelineContainer.classList.remove('hidden');
            runLabelPropagation();
        });

        timelineSlider.addEventListener('input', (e) => {
            const iteration = parseInt(e.target.value);
            iterationLabel.textContent = iteration;
            
            const currentLabels = history[iteration];
            if (currentLabels && g) {
                graphData.nodes.forEach((node, i) => {
                    node.label = currentLabels[i];
                });
                g.selectAll("circle").attr("fill", d => d.label !== null ? colors(d.label) : "#ccc");
            }
        });

        graphTypeSelect.addEventListener('change', updateParamsUI);

        // --- Inicialização ---
        window.addEventListener('load', () => {
            updateParamsUI();
        });
        
        window.addEventListener('resize', () => {
             width = document.getElementById('graph-container').clientWidth;
             height = document.getElementById('graph-container').clientHeight;
             svg.attr('width', width).attr('height', height);
             if (simulation) {
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();
             }
        });

    </script>
</body>
</html>
